package ksb.csle.didentification.privacy

import scala.collection.JavaConversions.asScalaBuffer
import scala.collection.mutable.Map
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.functions.udf

import ksb.csle.common.proto.StreamDidentProto._
import ksb.csle.common.proto.StreamControlProto.StreamOperatorInfo
import ksb.csle.common.proto.DatasourceProto.FieldInfo

import ksb.csle.didentification.verification.Verification
import ksb.csle.didentification.interfaces.DeAnonymizer
import ksb.csle.didentification.utilities.RandomGenerator

/**
 * :: ApplicationDeveloperApi ::
 *
 * Operator that implements the heuristic module in the PseudoAnonymization
 * algorithm. It replaces the values of data according to the generated
 * heuristic tables. This tables can be generated by following methods.
 * - Randomized Table: generated by random string (number, alphabet)
 * - Manual: insert the heuristic table list manually.
 * It manages the heuristic table internally and hence it is also capable of
 * de-anonymizing the anonmized records.
 *
 * @param o Object that contains message
 *          [[ksb.csle.common.proto.StreamDidentProto.HeuristicInfo]]
 *          HeuristicInfo contains attributes as follows:
 *          - selectedColumnId: Column ID to apply the heuristic function
 *          - method: how to apply heuristic function.  
 *          - manualInfo: changes the data with the given manual info
 *          - randInfo: changes the data randomly made string
 *          - fieldInfo: the info about column attributes (identifier, sensitive, ..)
 *          - check: the method how to verify the performance of anonymized data
 *          
 *  ==HeuristicInfo==
 *  {{{
 *  enum GenHeuristicTableMethod {
 *    HEUR_RANDOM = 0;
 *    HEUR_MANUAL = 1;
 *    HEUR_FILE = 2; // not used
 *  }
 *  message ManualInfo {
 *  	required string value = 1;
 *  	required string replaceValue = 2;
 *  }
 *  message RandomInfo {
 *  	required RandomMethod randMethod = 1 [default = MIXED];
 *  	required int32 length = 2 [default = 6];
 *  }
 *  message HeuristicInfo {
 *    repeated int32 selectedColumnId = 1;
 *    required GenHeuristicTableMethod method = 2 [default = HEUR_RANDOM];
 *    repeated ManualInfo manualInfo = 3;
 *    optional RandomInfo randInfo = 4;
 *    repeated FieldInfo fieldInfo = 5;
 *    optional PrivacyCheckInfo check = 6;
 *  }
 *  }}}
 */
class HeuristicOperator(o: StreamOperatorInfo)
  extends BasePrivacyAnonymizer(o, o.getHeuristic.getCheck)
  with DeAnonymizer {

  val p: HeuristicInfo = o.getHeuristic

  /**
   * Pseudo-anonymizes, that is, replaces the values of the column
   * in src dataframe with heuristic table. 'heuristicType' method denotes
   * how to make this table.
   *
   * @param src Dataframe to anonymize
   * @param columnName Column to be pseudo-anonymized
   * @return DataFrame Anonymized dataframe
   */
  override def anonymizeColumn(
      src: DataFrame,
      columnName: String): DataFrame =
    anonymizeColumn(src, columnName, p.getMethod)

  /**
   * Pseudo-anonymizes, that is, replaces the values of the column
   * in src dataframe with heuristic table. 'heuristicType' method denotes
   * how to make this table.
   *
   * @param src Dataframe to anonymize
   * @param columnName Column to be pseudo-anonymized
   * @param heuristicType How to make table
   * @return DataFrame Anonymized dataframe
   */
  def anonymizeColumn(
      src: DataFrame,
      columnName: String,
      heuristicType: GenHeuristicTableMethod): DataFrame = {
    val table = makeHeuristicTable(src, columnName, heuristicType)
    def heursticAnonymize: (String => String) = {
      key => table.get(key) match {
        case Some(value) => value
        case _ => key
      }
    }
    val heuristicUdf = udf(heursticAnonymize)
    val result = src.withColumn(columnName, heuristicUdf(src.col(columnName)))

//    result.show
//    to check de-anonymize capability
//    deAnonymize(result, columnName, table).show
    (result)
  }

  /**
   * generates heuristic table in order to change the original data by referring
   * to the generated table. It is composed of [original data, anonymized data]
   * and can be made by the following methods.
   * - RANDOM: makes the table generated by random strings.
   * - DESIGNATED: TO BE DEFINED
   *
   * @param src Dataframe to anonymize
   * @param columnName Column to be pseudo-anonymized
   * @param heuristicType How to make heuristic table
   * @return Map[String, String] Generated heuristic table
   */
  def makeHeuristicTable(
      src: DataFrame,
      columnName: String,
      heuristicType: GenHeuristicTableMethod): Map[String, String] = {
    heuristicType match {
      case GenHeuristicTableMethod.HEUR_RANDOM =>
        makeRandHeuristicTable(src, columnName, p.getRandInfo)
      case GenHeuristicTableMethod.HEUR_MANUAL =>
        makeManualHeuristicTable(p.getManualInfoList)
//      case GenHeuristicTableMethod.FILE =>
//        Swapping(o).anonymizeColumn(src, columnName, heuristicType)
      case _ => makeRandHeuristicTable(src, columnName, p.getRandInfo)
    }
  }

  private def makeManualHeuristicTable(
      manualList: java.util.List[ManualInfo]): Map[String, String] = {
    val table = Map[String, String]()
    manualList.map(manual =>
      table += (manual.getValue -> manual.getReplaceValue))
    (table)
  }

  /**
   * Makes heuristic table to change the original data by referring to the
   * given table. This table is composed of [original data, randomized string].
   * Randomized string can be composed of only numerical, or alphabet,
   * or both numerical and alphabet.
   *
   * @param src Dataframe to anonymize
   * @param columnName Column name to be pseudo-anonymized
   * @param randInfo How to make randomized heuristic table. It contains the
   * information about the method to make randomized string and their lengths.
   * @return Map[String, String] Generated heuristic table
   */
  private def makeRandHeuristicTable(
      src: DataFrame,
      columnName: String,
      randIndo: RandomInfo): Map[String, String] = {
    val table = Map[String, String]()
    val length = randIndo.getLength
    src.select(src.col(columnName)).dropDuplicates()
      .rdd.zipWithUniqueId.collect.map(r => {
      val key = r._1.toString.dropRight(1).drop(1)
      val randVal = randIndo.getRandMethod match {
        case RandomMethod.ALPHABET => RandomGenerator.randomAlpha(length)
        case RandomMethod.NUMBER => RandomGenerator.randomNumber(length).toString
        case RandomMethod.MIXED => RandomGenerator.randomMixed(length)
        case _ => RandomGenerator.randomMixed(length)
      }
      table += (key -> randVal)
    })

    (table)
  }

  /**
   * Operates heuristic module for basic de-identification
   *
   * @param runner BaseRunner to run
   * @param df Input dataframe
   * @return DataFrame Anonymized dataframe
   */
  override def operate(df: DataFrame): DataFrame = {
    val columnIDs: Array[Int] =
      (p.getSelectedColumnIdList map (_.asInstanceOf[Int])).toArray

    val result = anonymize(df, getColumnNames(df, columnIDs))
    
    val fieldInfos = (p.getFieldInfoList map (_.asInstanceOf[FieldInfo])).toArray
    Verification(privacy).printAnonymizeResult(df, result, fieldInfos)    
    (result)
  }

}

object HeuristicOperator {
  def apply(o: StreamOperatorInfo): HeuristicOperator = new HeuristicOperator(o)
}
